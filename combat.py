###########################################
""" combat manager """

# Imports
import os
import time
import random

import classes
import spells
import world
import character
import storyline
import items


# Functions
def statuses(char, end=False):
    if end:
        for key in list(char.status_effects.keys()):
            char.status_effects[key][0] = False
    else:
        if char.status_effects['Poison'][0]:
            char.status_effects['Poison'][1] -= 1
            poison_damage = char.status_effects['Poison'][2]
            poison_damage -= random.randint(0, char.con)
            if poison_damage > 0:
                poison_damage = random.randint(poison_damage // 2, poison_damage)
                char.health -= poison_damage
                print("The poison damages {} for {} health points.".format(char.name, poison_damage))
            else:
                print("{} resisted the poison.".format(char.name))
            if char.status_effects['Poison'][1] == 0:
                char.status_effects['Poison'][0] = False
                print("The poison has left {}.".format(char.name))
        if char.status_effects['DOT'][0]:
            char.status_effects['DOT'][1] -= 1
            dot_damage = char.status_effects['DOT'][2]
            dot_damage -= random.randint(0, char.wisdom)
            if dot_damage > 0:
                dot_damage = random.randint(dot_damage // 2, dot_damage)
                char.health -= dot_damage
                print("The magic damages {} for {} health points.".format(char.name, dot_damage))
            elif dot_damage < 0:
                char.health -= dot_damage
                print("{} absorbs the magic for {} health points.".format(char.name, dot_damage))
            else:
                print("{} resisted the magic.".format(char.name))
            if char.status_effects['DOT'][1] == 0:
                char.status_effects['DOT'][0] = False
                print("The magic affecting {} has worn off.".format(char.name))
        if char.status_effects['Blind'][0]:
            char.status_effects['Blind'][1] -= 1
            if char.status_effects['Blind'][1] == 0:
                print("{} is no longer blind.".format(char.name))
                char.status_effects['Blind'][0] = False
        if char.status_effects['Stun'][0]:
            char.status_effects['Stun'][1] -= 1
            if char.status_effects['Stun'][1] == 0:
                print("{} is no longer stunned.".format(char.name))
                char.status_effects['Stun'][0] = False
        if char.status_effects['Sleep'][0]:
            char.status_effects['Sleep'][1] -= 1
            if char.status_effects['Sleep'][1] == 0:
                print("{} is no longer asleep.".format(char.name))
                char.status_effects['Sleep'][0] = False
        if char.status_effects['Reflect'][0]:
            char.status_effects['Reflect'][1] -= 1
            if char.status_effects['Reflect'][1] == 0:
                print("{} is no longer reflecting magic.".format(char.name))
                char.status_effects['Reflect'][0] = False
        if char.status_effects['Bleed'][0]:
            char.status_effects['Bleed'][1] -= 1
            bleed_damage = char.status_effects['Bleed'][2]
            bleed_damage -= random.randint(0, char.con)
            if bleed_damage > 0:
                bleed_damage = random.randint(bleed_damage // 2, bleed_damage)
                char.health -= bleed_damage
                print("The bleed damages {} for {} health points.".format(char.name, bleed_damage))
            else:
                print("{} resisted the bleed.".format(char.name))
            if char.status_effects['Bleed'][1] == 0:
                char.status_effects['Bleed'][0] = False
                print("{}'s wounds have healed and is no longer bleeding.".format(char.name))
        if char.status_effects['Disarm'][0]:
            char.status_effects['Disarm'][1] -= 1
            if char.status_effects['Disarm'][1] == 0:
                print("{} picks up their weapon.".format(char.name))
                char.status_effects['Disarm'][0] = False
        if char.status_effects['Regen'][0]:
            char.status_effects['Regen'][1] -= 1
            heal = char.status_effects['Regen'][2]
            if heal > (char.health_max - char.health):
                heal = (char.health_max - char.health)
            char.health += heal
            print("{}'s health has regenerated by {}.".format(char.name, heal))
            if char.status_effects['Regen'][1] == 0:
                print("Regeneration spell ends.")
                char.status_effects['Regen'][0] = False
        # Doom needs to be last
        if char.status_effects['Doom'][0]:
            char.status_effects['Doom'][1] -= 1
            if char.status_effects['Doom'][1] == 0:
                print("The Doom countdown has expired and so has {}!".format(char.name))
                char.health = 0


def transform(player, t_creature=None, back=False):
    if back:
        print("{} transforms back into their normal self.".format(player.name))
        time.sleep(1)
        health_diff = player.health_max - player.health
        mana_diff = player.mana_max - player.mana
        player_dict = character.load_char(char=player, tmp=True)
        player.cls = player_dict['cls']
        if player.is_alive():
            player.health = max(1, player_dict['health_max'] - health_diff)
        player.health_max = player_dict['health_max']
        player.mana = max(0, player_dict['mana_max'] - mana_diff)
        player.mana_max = player_dict['mana_max']
        player.strength = player_dict['strength']
        player.intel = player_dict['intel']
        player.wisdom = player_dict['wisdom']
        player.con = player_dict['con']
        player.dex = player_dict['dex']
        player.equipment = player_dict['equipment']
        player.spellbook = player_dict['spellbook']
        player.resistance = player_dict['resistance']
    else:
        player.save(tmp=True)
        print("{} transforms into a {}.".format(player.name, t_creature.name))
        player.cls = t_creature.name
        player.health += t_creature.health
        player.health_max += t_creature.health_max
        player.mana += t_creature.mana
        player.mana_max += t_creature.mana_max
        player.strength += t_creature.strength
        player.intel += t_creature.intel
        player.wisdom += t_creature.wisdom
        player.con += t_creature.con
        player.dex += t_creature.dex
        player.equipment['Weapon'] = t_creature.equipment['Weapon']
        player.equipment['Armor'] = t_creature.equipment['Armor']
        player.equipment['OffHand'] = t_creature.equipment['OffHand']
        player.spellbook = t_creature.spellbook
        player.resistance = t_creature.resistance
        time.sleep(1)
        os.system('cls' if os.name == 'nt' else 'clear')


def familiar(player, enemy):
    fam = player.familiar
    special = None
    target = enemy
    if not random.randint(0, 1):
        if fam.spec == "Defense":  # skills and spells
            while True:
                if not random.randint(0, 1):
                    special_list = list(fam.spellbook['Spells'].keys())
                    special_type = "Spells"
                else:
                    special_list = list(fam.spellbook['Skills'].keys())
                    special_type = "Skills"
                if len(special_list) == 1:
                    special = fam.spellbook[special_type][special_list[0]]
                else:
                    choice = random.randint(0, len(special_list) - 1)
                    special = fam.spellbook[special_type][special_list[choice]]
                if special().name != 'Resurrection':
                    break
        if fam.spec == "Support":  # just spells
            target = player
            if not random.randint(0, 4) and player.mana < player.mana_max:
                mana_regen = int(player.mana_max * 0.05)
                if (player.mana + mana_regen) > player.mana_max:
                    mana_regen = player.mana_max - player.mana
                player.mana += mana_regen
                print("{} restores {}'s mana by {}.".format(fam.name, player.name, mana_regen))
            else:
                if player.health < player.health_max and random.randint(0, 1):
                    if random.randint(0, 1):
                        special = fam.spellbook['Spells']['Heal']
                    else:
                        special = fam.spellbook['Spells']['Regen']
                elif not player.status_effects['Attack'][0]:
                    special = fam.spellbook['Spells']['Bless']
                elif fam.level > 1 and not player.status_effects['Reflect'][0]:
                    special = fam.spellbook['Spells']['Reflect']
                elif fam.level == 3 and random.randint(0, 1):
                    special = fam.spellbook['Spells']['Cleanse']
                else:
                    if random.randint(0, 1):
                        special = fam.spellbook['Spells']['Heal']
                    else:
                        special = fam.spellbook['Spells']['Regen']
        if fam.spec == "Arcane":  # just spells
            spell_list = list(fam.spellbook['Spells'].keys())
            choice = random.randint(0, len(spell_list) - 1)
            if spell_list[choice] == "Boost" and not random.randint(0, 1) and not player.status_effects['Magic'][0]:
                special = fam.spellbook['Spells']['Boost']
                target = player
            else:
                special = fam.spellbook['Spells'][spell_list[choice]]
        if fam.spec == "Luck":
            if not random.randint(0, 4):
                special = fam.spellbook['Spells']['Corruption']
            else:
                while True:
                    skill_list = list(fam.spellbook['Skills'].keys())
                    choice = random.randint(0, len(skill_list) - 1)
                    if skill_list[choice] == 'Lockpick':
                        pass
                    else:
                        special = fam.spellbook['Skills'][skill_list[choice]]
                        break
        if special is not None:
            if special().typ == 'Skill':
                special().use(player, target=target, fam=True)
            elif special().typ == 'Spell':
                special().cast(player, target=target, fam=True)


def absorb_essence(player, enemy):
    """
    Currently 5% chance
    Different monster types improve different stats
    Reptile: increase strength
    Aberration: increase intelligence
    Slime: increase wisdom
    Construct: increase constitution
    Humanoid: increase charisma
    Insect: increase dexterity
    Animal: increase max health
    Monster: increase max mana
    Undead: increase level
    Dragon: increase gold
    """
    chance = max(1, 19 - player.check_mod('luck', luck_factor=20))
    if not random.randint(0, chance):  # 5% chance on kill
        print("You absorb part of the {}'s soul.".format(enemy.name))
        time.sleep(1)
        if enemy.enemy_typ == 'Reptile':
            print("Gain 1 strength.")
            player.strength += 1
        if enemy.enemy_typ == 'Aberration':
            print("Gain 1 intelligence.")
            player.intel += 1
        if enemy.enemy_typ == 'Slime':
            print("Gain 1 wisdom.")
            player.wisdom += 1
        if enemy.enemy_typ == 'Construct':
            print("Gain 1 constitution.")
            player.con += 1
        if enemy.enemy_typ == 'Humanoid':
            print("Gain 1 charisma.")
            player.charisma += 1
        if enemy.enemy_typ == 'Insect':
            print("Gain 1 dexterity.")
            player.dex += 1
        if enemy.enemy_typ == 'Animal':
            print("Gain 5 hit points.")
            player.health_max += 5
        if enemy.enemy_typ == 'Monster':
            print("Gain 5 mana points.")
            player.mana_max += 5
        if enemy.enemy_typ == 'Undead':
            print("Gain enough experience to level.")
            player.experience = player.exp_to_gain
            player.level_up()
        if enemy.enemy_typ == 'Dragon':
            print("Your gold has been doubled.")
            player.gold *= 2
        time.sleep(1)


def weapon_damage(attacker, defender, dmg_mod=0, crit=1, ignore=False, cover=False):
    """
    Function that controls melee attacks during combat
    """
    hit = False  # indicates if the attack was successful for means of ability/weapon affects
    attacks = ['Weapon']
    if attacker.equipment['OffHand']().typ == 'Weapon':
        attacks.append('OffHand')
    for att in attacks:
        if not ignore:
            ignore = attacker.equipment[att]().ignore
        # attacker variables
        typ = 'attacks'
        if attacker.equipment[att]().subtyp == 'Natural':
            typ = attacker.equipment[att]().name
            if typ == 'leers':
                hit = True
                break
        hit_mod = 1 + int(attacker.status_effects['Blind'][0])
        if crit == 1:
            if not random.randint(0, int(attacker.equipment[att]().crit)):
                crit = 2
        dmg = max(1, dmg_mod + attacker.check_mod(att.lower()))
        damage = max(0, int(random.randint(dmg // 2, dmg) * crit))

        # defender variables
        stun = defender.status_effects['Stun'][0]
        sleep = defender.status_effects['Sleep'][0]
        dam_red = defender.check_mod('armor') * int(not ignore)
        resist = defender.check_mod('resist', typ='Physical')
        chance = defender.check_mod('luck', luck_factor=15)
        dodge = random.randint(0, defender.dex // 2) + chance > random.randint(attacker.dex // (2 * hit_mod),
                                                                               attacker.dex // hit_mod)
        if stun or sleep:
            dodge = False

        # combat
        if dodge:
            if not stun and not sleep:
                if 'Parry' in list(defender.spellbook['Skills'].keys()):  # TODO need to prevent infinite loop
                    print("{} parries {}'s attack and counterattacks!".format(defender.name, attacker.name))
                    _, _ = weapon_damage(defender, attacker)
                else:
                    print("{} evades {}'s attack.".format(defender.name, attacker.name))
            else:  # TODO remove after testing
                print("This section shouldn't be reached.")
                raise NotImplementedError
        else:
            hit = True
            if crit > 1:
                print("Critical hit!")
            if cover:
                print("{} steps in front of the attack, taking the damage for {}.".format(
                    defender.familiar.name, defender.name))
                damage = 0
            elif (defender.equipment['OffHand']().subtyp == 'Shield' and
                  not defender.status_effects['Mana Shield'][0]) and (not stun and not sleep):
                if not random.randint(0, int(defender.equipment['OffHand']().mod)):
                    blk_amt = (100 / defender.equipment['OffHand']().mod +
                               random.randint(defender.strength // 2, defender.strength) -
                               random.randint(attacker.strength // 2, attacker.strength)) / 100
                    if blk_amt <= 0:
                        print("{} attempts to block {}'s attack but isn't strong enough.".format(
                            defender.name, attacker.name))
                    else:
                        if 'Shield Block' in list(defender.spellbook['Skills'].keys()):
                            blk_amt *= 2
                        blk_amt = min(1, blk_amt)
                        damage *= (1 - blk_amt)
                        damage = int(damage * (1 - resist))
                        print("{} blocks {}'s attack and mitigates {} percent of the damage.".format(
                            defender.name, attacker.name, int(blk_amt * 100)))
            elif defender.status_effects['Mana Shield'][0]:
                damage //= defender.status_effects['Mana Shield'][1]
                if damage > defender.mana:
                    print("The mana shield around {} absorbs {} damage.".format(defender.name, defender.mana))
                    damage -= defender.mana  # TODO test
                    defender.mana = 0
                    defender.status_effects['Mana Shield'][0] = False
                else:
                    print("The mana shield around {} absorbs {} damage.".format(defender.name, damage))
                    defender.mana -= damage
                    damage = 0
                    hit = False
            if damage > 0:
                damage = max(0, int((damage - dam_red) * (1 - resist)))
                defender.health -= damage
                if damage > 0:
                    print("{} {} {} for {} damage.".format(attacker.name, typ, defender.name, damage))
                    if sleep:
                        if not random.randint(0, 1):
                            print("The attack awakens {}!".format(defender.name))
                            defender.status_effects['Sleep'][0] = False
                            defender.status_effects['Sleep'][1] = 0
                else:
                    print("{} {} {} but deals no damage.".format(attacker.name, typ, defender.name))
                    hit = False
            else:
                print("{} {} {} but deals no damage.".format(attacker.name, typ, defender.name))
                hit = False
            time.sleep(0.5)
        if hit and attacker.equipment[att]().special and defender.is_alive():
            attacker.equipment[att]().special_effect(attacker, defender, damage=damage, crit=crit)
        time.sleep(0.5)
        if not defender.is_alive():
            break
    return hit, crit


def options(player, action_list=None):
    """
    Controls the listed options during combat
    """
    print("Choose an action:")
    if action_list is not None:
        option_list = []
        for action in action_list:
            option_list.append(action.name)
        if player.status_effects['Mana Shield'][0]:  # TODO test
            option_list.append("Remove Shield")
        action_input = storyline.get_response(option_list)
        return action_input


def player_turn(player, enemy, tile, available_actions, combat):
    valid_entry = False
    flee = False
    move = False
    action_input = options(player, available_actions)
    try:
        action = available_actions[action_input]
    except IndexError:
        action = 'Remove Shield'
    if action == 'Remove Shield':
        print("The mana shield dissolves around {}.".format(player.name))
        player.status_effects['Mana Shield'][0] = False
        valid_entry = False
        time.sleep(0.5)
    else:
        if 'Move' in action.name:
            combat = False
            player.state = 'normal'
            valid_entry = True
            player.do_action(action, **action.kwargs)
            move = True
            return valid_entry, combat, move
        if action.name == 'Open':
            player.open_up(enemy)
            combat = False
            valid_entry = True
        if action.name == 'Attack':
            _, _ = weapon_damage(player, enemy)
            valid_entry = True
        if action.name == 'Item':
            valid_entry = player.use_item()
        if action.name == 'Flee':
            flee = character.Player.flee(player, enemy)
            valid_entry = True
        if action.name == 'Cast Spell':
            spell_list = []
            for entry in player.spellbook['Spells']:
                if player.spellbook['Spells'][entry]().subtyp == "Movement":
                    continue
                elif player.spellbook['Spells'][entry]().cost <= player.mana:
                    spell_list.append(str(entry) + '  ' + str(player.spellbook['Spells'][entry]().cost))
            spell_list.append('Go Back')
            spell_index = storyline.get_response(spell_list)
            if spell_list[spell_index] == 'Go Back':
                os.system('cls' if os.name == 'nt' else 'clear')
                return False, combat, move
            else:
                spell = player.spellbook['Spells'][spell_list[spell_index].split('  ')[0]]
                spell().cast(player, enemy)
                valid_entry = True
        if action.name == 'Use Skill':
            skill_list = []
            for entry in player.spellbook['Skills']:
                if player.spellbook['Skills'][entry]().cost <= player.mana:
                    if player.spellbook['Skills'][entry]().passive:
                        continue
                    elif player.spellbook['Skills'][entry]().name == 'Smoke Screen' and 'Boss' in \
                            tile.intro_text(player):
                        continue
                    elif player.spellbook['Skills'][entry]().name == 'Lockpick':
                        continue
                    elif player.spellbook['Skills'][entry]().name == 'Shield Slam' and \
                            player.equipment['OffHand']().subtyp != 'Shield':
                        continue
                    else:
                        skill_list.append(str(entry) + '  ' + str(player.spellbook['Skills'][entry]().cost))
            skill_list.append('Go Back')
            skill_index = storyline.get_response(skill_list)
            if skill_list[skill_index] == 'Go Back':
                os.system('cls' if os.name == 'nt' else 'clear')
                return False, combat, move
            else:
                valid = True
                skill = player.spellbook['Skills'][skill_list[skill_index].split('  ')[0]]
                if skill().name == 'Smoke Screen':
                    player.mana -= skill().cost
                    flee = player.flee(enemy, smoke=True)
                elif skill().name == 'Transform':
                    skill().change(player)
                    valid = False
                else:
                    skill().use(player, enemy)
                valid_entry = valid
    if flee:
        """Moves the player randomly to an adjacent tile"""
        time.sleep(0.5)
        available_moves = tile.adjacent_moves()
        r = random.randint(0, len(available_moves) - 1)
        player.do_action(available_moves[r])
        combat = False
    return valid_entry, combat, move


def enemy_turn(player, enemy, combat):
    def choose_action():
        action_list = ['Attack']
        for spell_name, spell in enemy.spellbook['Spells'].items():
            if enemy.spellbook['Spells'][spell_name]().cost <= enemy.mana:
                action_list.append(spell)
        for skill_name, skill in enemy.spellbook['Skills'].items():
            if enemy.spellbook['Skills'][skill_name]().passive:
                continue
            elif enemy.spellbook['Skills'][skill_name]().cost <= enemy.mana:
                action_list.append(skill)
        return random.choice(action_list)

    cover = False
    if not enemy.is_alive():
        print("{} killed the {}.".format(player.name, enemy.name))
        if player.cls not in list(classes.classes_dict.keys()):
            transform(player, back=True)
        print("{} gained {} experience.".format(player.name, enemy.experience))
        player.loot(enemy)
        player.experience += enemy.experience
        while player.experience >= player.exp_to_gain:
            player.level_up()
        if player.cls == "Soulcatcher":
            absorb_essence(player, enemy)
        if player.cls in ['Warlock', 'Shadowcaster']:
            if player.familiar.typ == 'Jinkin' and player.familiar.pro_level == 3:
                if not random.randint(0, 9):
                    rand_item = items.random_item(player.location_z)
                    if not random.randint(0, 1):
                        print("{} finds {} but keeps it for themself.".format(
                            player.familiar.name, rand_item().name))
                    else:
                        player.modify_inventory(rand_item, 1)
                        print("{} finds {} and gives it to {}.".format(
                            player.familiar.name, rand_item().name, player.name))
        if player.cls == "Lycan" and enemy.name == 'Red Dragon':
            print("{} has harnessed the power of the Red Dragon and can now transform into one!".format(player.name))
            player.spellbook['Skills']['Transform'] = spells.Transform4
        player.state = 'normal'
        statuses(player, end=True)
        return False
    elif player.state == 'normal':
        return False
    elif enemy.status_effects['Stun'][0] or enemy.status_effects['Sleep'][0]:
        combat = True
    else:
        if player.cls in ['Warlock', 'Shadowcaster']:
            if 'Cover' in list(player.familiar.spellbook['Skills'].keys()) and not random.randint(0, 3):
                cover = True
        action = choose_action()
        if action == "Attack":
            _, _ = weapon_damage(enemy, player, cover=cover)
        elif action().typ == "Skill":
            _ = action().use(enemy, player, cover=cover)
            if action().name == "Shapeshift":
                _, _ = weapon_damage(enemy, player, cover=cover)
            try:
                if action().rank == 1:
                    if (player.cls == "Diviner" or player.cls == "Geomancer") and \
                            action().name not in player.spellbook['Skills']:
                        player.spellbook['Skills'][action().name] = action
                        print(action())
                        print("You have gained the ability to cast {}.".format(action().name))
                elif action().rank == 2:
                    if player.cls == "Geomancer" and action().name not in player.spellbook['Skills']:
                        player.spellbook['Skills'][action().name] = action
                        print(action())
                        print("You have gained the ability to cast {}.".format(action().name))
            except AttributeError:
                pass
        elif action().typ == "Spell":
            action().cast(enemy, player, cover=cover)
            try:
                if action().rank == 1:
                    if (player.cls == "Diviner" or player.cls == "Geomancer") and \
                            action().name not in player.spellbook['Spells']:
                        player.spellbook['Spells'][action().name] = action
                        print(action())
                        print("You have gained the ability to cast {}.".format(action().name))
                elif action().rank == 2:
                    if player.cls == "Geomancer" and action().name not in player.spellbook['Spells']:
                        player.spellbook['Spells'][action().name] = action
                        print(action())
                        print("You have gained the ability to cast {}.".format(action().name))
            except AttributeError:
                pass
        else:
            print("Shouldn't reach here")
            raise BaseException
        if enemy.health <= 0:
            print("{} killed the {}.".format(player.name, enemy.name))
            if player.cls not in list(classes.classes_dict.keys()):
                transform(player, back=True)
            print("{} gained {} experience.".format(player.name, enemy.experience))
            player.loot(enemy)
            player.experience += enemy.experience
            while player.experience >= player.exp_to_gain:
                player.level_up()
            player.state = 'normal'
            return False
    if not player.is_alive():
        try:
            if 'Resurrection' in list(player.familiar.spellbook['Spells'].keys()) and random.randint(0, 1):
                spells.Resurrection().cast(player.familiar, target=player, fam=True)
        except AttributeError:
            pass
        if 'Resurrection' in list(player.spellbook['Spells'].keys()) and abs(player.health) <= player.mana:
            player.spellbook['Spells']['Resurrection']().cast(player, enemy)
        else:
            if player.cls not in list(classes.classes_dict.keys()):
                transform(player, back=True)
            print("{} was slain by {}.".format(player.name, enemy.name))
            statuses(player, end=True)
            enemy.health = enemy.health_max
            enemy.mana = enemy.mana_max
            statuses(enemy, end=True)
            return False
    statuses(enemy)
    if not enemy.is_alive():
        print("{} killed the {}.".format(player.name, enemy.name))
        if player.cls not in list(classes.classes_dict.keys()):
            transform(player, back=True)
        print("{} gained {} experience.".format(player.name, enemy.experience))
        player.loot(enemy)
        player.experience += enemy.experience
        while player.experience >= player.exp_to_gain:
            player.level_up()
        if player.cls == "Soulcatcher":
            absorb_essence(player, enemy)
        if player.cls in ['Warlock', 'Shadowcaster']:
            if player.familiar.typ == 'Jinkin' and player.familiar.pro_level == 3:
                if not random.randint(0, 9):
                    rand_item = items.random_item(player.location_z)
                    if not random.randint(0, 1):  # TODO might remove
                        print("{} finds {} but keeps it for themself.".format(
                            player.familiar.name, rand_item().name))
                    else:
                        player.modify_inventory(rand_item, 1)
                        print("{} finds {} and gives it to {}.".format(
                            player.familiar.name, rand_item().name, player.name))
        if player.cls == "Lycan" and enemy.name == 'Red Dragon':
            print("{} has harnessed the power of the Red Dragon and can now transform into one!".format(player.name))
            player.spellbook['Skills']['Transform'] = spells.Transform4
        player.state = 'normal'
        statuses(player, end=True)
        return False
    return combat


def battle(player, enemy):
    """
    Function that controls combat
    """
    tile = world.tile_exists(player.location_x, player.location_y, player.location_z)
    available_actions = tile.available_actions(player)
    combat = True
    move = False
    while player.is_alive() and enemy.is_alive():
        os.system('cls' if os.name == 'nt' else 'clear')
        tile.minimap(player)
        print(tile.intro_text(player))
        if player.cls == 'Inquisitor' or player.cls == 'Seeker' or 'Vision' in player.equipment['Pendant']().mod:
            print(enemy)
        print("Player: {} | Health: {}/{} | Mana: {}/{}".format(player.name, player.health, player.health_max,
                                                                player.mana, player.mana_max))
        if not player.status_effects['Stun'][0] and not player.status_effects['Sleep'][0]:
            while True:
                valid_entry, combat, move = player_turn(player, enemy, tile, available_actions, combat)
                if valid_entry:
                    break
                else:
                    os.system('cls' if os.name == 'nt' else 'clear')
                    tile.minimap(player)
                    print(tile.intro_text(player))
                    if (player.cls == 'Inquisitor' or player.cls == 'Seeker' or
                            'Vision' in player.equipment['Pendant']().mod):
                        print(enemy)
                    print(
                        "Player: {} | Health: {}/{} | Mana: {}/{}".format(player.name, player.health, player.health_max,
                                                                          player.mana, player.mana_max))
                if player.cls not in list(classes.classes_dict.keys()):
                    available_actions = tile.available_actions(player)
        if move:
            break
        if combat:
            time.sleep(0.5)
        statuses(player)

        # Familiar's turn
        if combat:
            if player.cls in ['Warlock', 'Shadowcaster'] and enemy.is_alive():
                familiar(player, enemy)

        if not player.is_alive():
            if 'Resurrection' in list(player.spellbook['Spells'].keys()) and abs(player.health) <= player.mana:
                player.spellbook['Spells']['Resurrection']().cast(player, enemy)
            else:
                if player.cls not in list(classes.classes_dict.keys()):
                    transform(player, back=True)
                print("{} was slain by {}.".format(player.name, enemy.name))
                statuses(player, end=True)
                enemy.health = enemy.health_max
                enemy.mana = enemy.mana_max
                statuses(enemy, end=True)
            combat = False

        # Enemies turn
        if combat:
            combat = enemy_turn(player, enemy, combat)
        if not combat:
            break
        input("Press enter to continue")

    player.state = 'normal'
    statuses(player, end=True)
