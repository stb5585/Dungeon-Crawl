###########################################
""" combat manager """

# Imports
import os
import time
import random

import classes
import spells
import world
import actions
import character
import storyline
import items


# Functions
def statuses(char):
    if char.status_effects['Poison'][0]:
        char.status_effects['Poison'][1] -= 1
        poison_damage = char.status_effects['Poison'][2]
        poison_damage -= random.randint(0, char.con)
        if poison_damage > 0:
            poison_damage = random.randint(poison_damage // 2, poison_damage)
            char.health -= poison_damage
            print("The poison damages {} for {} health points.".format(char.name, poison_damage))
        else:
            print("{} resisted the poison.".format(char.name))
        if char.status_effects['Poison'][1] == 0:
            char.status_effects['Poison'][0] = False
            print("The poison has left {}.".format(char.name))
    if char.status_effects['DOT'][0]:
        char.status_effects['DOT'][1] -= 1
        dot_damage = char.status_effects['DOT'][2]
        dot_damage -= random.randint(0, char.wisdom)
        if dot_damage > 0:
            dot_damage = random.randint(dot_damage // 2, dot_damage)
            char.health -= dot_damage
            print("The magic damages {} for {} health points.".format(char.name, dot_damage))
        else:
            print("{} resisted the spell.".format(char.name))
        if char.status_effects['DOT'][1] == 0:
            char.status_effects['DOT'][0] = False
            print("The magic affecting {} has worn off.".format(char.name))
    if char.status_effects['Doom'][0]:
        char.status_effects['Doom'][1] -= 1
        if char.status_effects['Doom'][1] == 0:
            print("The Doom countdown has expired and so has {}!".format(char.name))
            char.health = 0
    if char.status_effects['Blind'][0]:
        char.status_effects['Blind'][1] -= 1
        if char.status_effects['Blind'][1] == 0:
            print("{} is no longer blind.".format(char.name))
            char.status_effects['Blind'][0] = False
    if char.status_effects['Stun'][0]:
        char.status_effects['Stun'][1] -= 1
        if char.status_effects['Stun'][1] == 0:
            print("{} is no longer stunned.".format(char.name))
            char.status_effects['Stun'][0] = False
    if char.status_effects['Sleep'][0]:
        char.status_effects['Sleep'][1] -= 1
        if char.status_effects['Sleep'][1] == 0:
            print("{} is no longer asleep.".format(char.name))
            char.status_effects['Sleep'][0] = False
    if char.status_effects['Reflect'][0]:
        char.status_effects['Reflect'][1] -= 1
        if char.status_effects['Reflect'][1] == 0:
            print("{} is no longer reflecting magic.".format(char.name))
            char.status_effects['Reflect'][0] = False
    if char.status_effects['Bleed'][0]:
        char.status_effects['Bleed'][1] -= 1
        bleed_damage = char.status_effects['Bleed'][2]
        bleed_damage -= random.randint(0, char.con)
        if bleed_damage > 0:
            bleed_damage = random.randint(bleed_damage // 2, bleed_damage)
            char.health -= bleed_damage
            print("The bleed damages {} for {} health points.".format(char.name, bleed_damage))
        else:
            print("{} resisted the bleed.".format(char.name))
        if char.status_effects['Bleed'][1] == 0:
            char.status_effects['Bleed'][0] = False
            print("{}'s wounds have healed and is no longer bleeding.".format(char.name))
    if char.status_effects['Disarm'][0]:
        char.status_effects['Disarm'][1] -= 1
        if char.status_effects['Disarm'][1] == 0:
            print("{} picks up their weapon.".format(char.name))
            char.status_effects['Disarm'][0] = False
    if char.status_effects['Regen'][0]:
        char.status_effects['Regen'][1] -= 1
        heal = char.status_effects['Regen'][2]
        if heal > (char.health_max - char.health):
            heal = (char.health_max - char.health)
        char.health += heal
        print("{}'s health has regenerated by {}.".format(char.name, heal))
        if char.status_effects['Regen'][1] == 0:
            char.status_effects['Regen'][0] = False


def transform(player, t_creature=None, back=False):
    if back:
        print("{} transforms back into their normal self.".format(player.name))
        time.sleep(1)
        health_diff = player.health_max - player.health
        mana_diff = player.mana_max - player.mana
        player_dict = character.load_char(char=player, tmp=True)
        player.cls = player_dict['cls']
        if player.is_alive():
            player.health = max(1, player_dict['health_max'] - health_diff)
        player.health_max = player_dict['health_max']
        player.mana = max(0, player_dict['mana_max'] - mana_diff)
        player.mana_max = player_dict['mana_max']
        player.strength = player_dict['strength']
        player.intel = player_dict['intel']
        player.wisdom = player_dict['wisdom']
        player.con = player_dict['con']
        player.dex = player_dict['dex']
        player.equipment = player_dict['equipment']
        player.spellbook = player_dict['spellbook']
        player.resistance = player_dict['resistance']
    else:
        player.save(tmp=True)
        print("{} transforms into a {}.".format(player.name, t_creature.name))
        player.cls = t_creature.name
        player.health += t_creature.health
        player.health_max += t_creature.health_max
        player.mana += t_creature.mana
        player.mana_max += t_creature.mana_max
        player.strength += t_creature.strength
        player.intel += t_creature.intel
        player.wisdom += t_creature.wisdom
        player.con += t_creature.con
        player.dex += t_creature.dex
        player.equipment['Weapon'] = t_creature.equipment['Weapon']
        player.equipment['Armor'] = t_creature.equipment['Armor']
        player.equipment['OffHand'] = t_creature.equipment['OffHand']
        player.spellbook = t_creature.spellbook
        player.resistance = t_creature.resistance
        time.sleep(1)
        os.system('cls' if os.name == 'nt' else 'clear')


def familiar(player, enemy):
    fam = player.familiar
    special = None
    target = enemy
    if not random.randint(0, 1):
        if fam.spec == "Defense":  # skills and spells
            while True:
                if not random.randint(0, 1):
                    special_list = list(fam.spellbook['Spells'].keys())
                    special_type = "Spells"
                else:
                    special_list = list(fam.spellbook['Skills'].keys())
                    special_type = "Skills"
                if len(special_list) == 1:
                    special = fam.spellbook[special_type][special_list[0]]
                else:
                    choice = random.randint(0, len(special_list) - 1)
                    special = fam.spellbook[special_type][special_list[choice]]
                if special().name != 'Resurrection':
                    break
        if fam.spec == "Support":  # just spells
            target = player
            if not random.randint(0, 4) and player.mana < player.mana_max:
                mana_regen = int(player.mana_max * 0.05)
                if (player.mana + mana_regen) > player.mana_max:
                    mana_regen = player.mana_max - player.mana
                player.mana += mana_regen
                print("{} restores {}'s mana by {}.".format(fam.name, player.name, mana_regen))
            else:
                if player.health < player.health_max and random.randint(0, 1):
                    if random.randint(0, 1):
                        special = fam.spellbook['Spells']['Heal']
                    else:
                        special = fam.spellbook['Spells']['Regen']
                elif not player.status_effects['Attack'][0]:
                    special = fam.spellbook['Spells']['Bless']
                elif fam.level > 1 and not player.status_effects['Reflect'][0]:
                    special = fam.spellbook['Spells']['Reflect']
                elif fam.level == 3 and random.randint(0, 1):
                    special = fam.spellbook['Spells']['Cleanse']
                else:
                    if random.randint(0, 1):
                        special = fam.spellbook['Spells']['Heal']
                    else:
                        special = fam.spellbook['Spells']['Regen']
        if fam.spec == "Arcane":  # just spells
            spell_list = list(fam.spellbook['Spells'].keys())
            choice = random.randint(0, len(spell_list) - 1)
            if spell_list[choice] == "Boost" and not random.randint(0, 1) and not player.status_effects['Magic'][0]:
                special = fam.spellbook['Spells']['Boost']
                target = player
            else:
                special = fam.spellbook['Spells'][spell_list[choice]]
        if fam.spec == "Luck":
            if not random.randint(0, 4):
                special = fam.spellbook['Spells']['Corruption']
            else:
                while True:
                    skill_list = list(fam.spellbook['Skills'].keys())
                    choice = random.randint(0, len(skill_list) - 1)
                    if skill_list[choice] == 'Lockpick':
                        pass
                    else:
                        special = fam.spellbook['Skills'][skill_list[choice]]
                        break
        if special is not None:
            if special().typ == 'Skill':
                special().use(player, target=target, fam=True)
            elif special().typ == 'Spell':
                special().cast(player, target=target, fam=True)


def absorb_essence(player, enemy):
    """
    Currently 5% chance
    Different monster types improve different stats
    Reptile: increase strength
    Aberration: increase intelligence
    Slime: increase wisdom
    Construct: increase constitution
    Humanoid: increase charisma
    Insect: increase dexterity
    Animal: increase max health
    Monster: increase max mana
    Undead: increase level
    Dragon: increase gold
    """
    chance = max(1, 19 - player.check_mod('luck', luck_factor=20))
    if not random.randint(0, chance):  # 5% chance on kill
        print("You absorb part of the {}'s soul.".format(enemy.name))
        time.sleep(1)
        if enemy.enemy_typ == 'Reptile':
            print("Gain 1 strength.")
            player.strength += 1
        if enemy.enemy_typ == 'Aberration':
            print("Gain 1 intelligence.")
            player.intel += 1
        if enemy.enemy_typ == 'Slime':
            print("Gain 1 wisdom.")
            player.wisdom += 1
        if enemy.enemy_typ == 'Construct':
            print("Gain 1 constitution.")
            player.con += 1
        if enemy.enemy_typ == 'Humanoid':
            print("Gain 1 charisma.")
            player.charisma += 1
        if enemy.enemy_typ == 'Insect':
            print("Gain 1 dexterity.")
            player.dex += 1
        if enemy.enemy_typ == 'Animal':
            print("Gain 5 hit points.")
            player.health_max += 5
        if enemy.enemy_typ == 'Monster':
            print("Gain 5 mana points.")
            player.mana_max += 5
        if enemy.enemy_typ == 'Undead':
            print("Gain enough experience to level.")
            player.experience = player.exp_to_gain
            player.level_up()
        if enemy.enemy_typ == 'Dragon':
            print("Your gold has been doubled.")
            player.gold *= 2
        time.sleep(1)


def weapon_damage(attacker, defender, fam=False, cover=False, crit=1, dmg_mod=0, ignore=False):
    """
    Function that controls melee attacks during combat
    """
    if fam:
        name = attacker.familiar.name
    else:
        name = attacker.name
    typ = 'attacks'
    off_typ = 'attacks'
    stun = defender.status_effects['Stun'][0]
    sleep = defender.status_effects['Sleep'][0]
    resist = defender.resistance['Physical']
    if attacker.equipment['Weapon']().subtyp == 'Natural':
        typ = attacker.equipment['Weapon']().name
        if attacker.equipment['OffHand']().subtyp == 'Natural':
            off_typ = attacker.equipment['OffHand']().name
    hit = False  # indicates if the attack was successful for means of ability/weapon affects
    if typ == 'leers':
        print("{} {} at {}.".format(name, typ, defender.name))
        spells.Petrify().cast(attacker, defender)
        return True, crit
    hit_mod = 1
    dmg_mod += attacker.check_mod('weapon')
    off_dmg_mod = attacker.check_mod('off')
    dam_red = defender.check_mod('armor')
    dodge = False
    off_dodge = False
    if attacker.status_effects['Blind'][0]:
        hit_mod = 2
    if crit == 1:
        if not random.randint(0, int(attacker.equipment['Weapon']().crit)):
            crit = 2
    off_crit = 1
    if attacker.equipment['OffHand']().typ == 'Weapon':
        if not random.randint(0, int(attacker.equipment['OffHand']().crit)):
            off_crit = 2
    if stun or sleep and hit_mod == 1:
        if crit > 1:
            print("Critical hit!")
        dmg = max(1, dmg_mod - dam_red)
        damage = max(1, int(random.randint(dmg // 2, dmg) * crit))
        damage = int(damage * (1 - resist))
        if cover:
            print("{} steps in front of the attack, taking the damage for {}.".format(
                defender.familiar.name, defender.name))
        else:
            defender.health -= damage
            print("{} {} {} for {} damage.".format(name, typ, defender.name, damage))
        if attacker.equipment['OffHand']().typ == 'Weapon':
            if off_crit > 1:
                print("Critical offhand hit!")
            off_dmg = max(1, off_dmg_mod - dam_red)
            off_damage = max(1, int(random.randint(off_dmg // 2, off_dmg) * off_crit))
            off_damage = int(off_damage * (1 - resist))
            if cover:
                print("{} steps in front of the attack, taking the damage for {}.".format(
                    defender.familiar.name, defender.name))
            else:
                print("{} {} {} for {} damage.".format(name, typ, defender.name, off_damage))
                defender.health -= off_damage
        hit = True
        if sleep:
            if not random.randint(0, 1):  # 50% chance to awaken TODO test
                defender.status_effects['Sleep'][0] = False
                defender.status_effects['Sleep'][1] = 0
        time.sleep(0.5)
    else:
        chance = defender.check_mod('luck', luck_factor=15)
        if random.randint(0, defender.dex // 2) + chance > \
                random.randint(attacker.dex // (2 * hit_mod), attacker.dex // hit_mod):
            dodge = True
        if attacker.equipment['OffHand']().typ == 'Weapon':
            if random.randint(0, defender.dex // 2) + chance > \
                    random.randint(attacker.dex // (2 * hit_mod), attacker.dex // hit_mod):
                off_dodge = True
        if not dodge:
            hit = True
            if crit > 1:
                print("Critical hit!")
            if ignore:
                dmg = max(1, dmg_mod)
                damage = max(1, int(random.randint((dmg // 2), dmg) * crit))
                damage = int(damage * (1 - resist))
            else:
                dmg = max(1, (dmg_mod - dam_red))
                damage = max(1, random.randint(dmg // 2, dmg) * crit)
                damage = int(damage * (1 - resist))
                if defender.equipment['OffHand']().subtyp == 'Shield':
                    if not random.randint(0, int(defender.equipment['OffHand']().mod)):
                        blk_amt = (100 / defender.equipment['OffHand']().mod +
                                   random.randint(defender.strength // 2, defender.strength) -
                                   random.randint(attacker.strength // 2, attacker.strength)) / 100
                        if blk_amt <= 0:
                            print("{} attempts to block {}'s attack but isn't strong enough.".format(
                                defender.name, name))
                        else:
                            if 'Shield Block' in list(defender.spellbook['Skills'].keys()):
                                blk_amt *= 2
                            blk_amt = min(1, blk_amt)
                            damage *= (1 - blk_amt)
                            damage = int(damage * (1 - resist))
                            print("{} blocks {}'s attack and mitigates {} percent of the damage.".format(
                                defender.name, name, int(blk_amt * 100)))
            if int(damage) > 0:
                if cover:
                    print("{} steps in front of the attack, taking the damage for {}.".format(
                        defender.familiar.name, defender.name))
                else:
                    print("{} {} {} for {} damage.".format(name, typ, defender.name, damage))
                    defender.health -= damage
            else:
                print("{} {} {} but deals no damage.".format(name, typ, defender.name))
        else:
            if 'Parry' in list(defender.spellbook['Skills'].keys()):  # TODO need to prevent infinite loop
                print("{} parries {}'s attack and counterattacks!".format(defender.name, name))
                _, _ = weapon_damage(defender, attacker)
            else:
                print("{} evades {}'s attack.".format(defender.name, name))
        time.sleep(0.5)
        if not off_dodge:
            if attacker.equipment['OffHand']().typ == 'Weapon':
                if off_crit > 1:
                    print("Critical offhand hit!")
                if ignore:
                    off_dmg = max(1, off_dmg_mod)
                    off_damage = max(0, int(random.randint((off_dmg // 2), off_dmg) * off_crit))
                    off_damage = int(off_damage * (1 - resist))
                else:
                    off_dmg = max(1, off_dmg_mod - dam_red)
                    off_damage = max(0, int(random.randint(off_dmg // 2, off_dmg) * off_crit))
                    off_damage = int(off_damage * (1 - resist))
                    if defender.equipment['OffHand']().subtyp == 'Shield':
                        if not random.randint(0, int(defender.equipment['OffHand']().mod)):
                            off_blk_amt = (100 / defender.equipment['OffHand']().mod +
                                           random.randint(defender.strength // 2, defender.strength) -
                                           random.randint(attacker.strength // 2, attacker.strength)) / 100
                            if 'Shield Block' in list(defender.spellbook['Skills'].keys()):
                                off_blk_amt *= 2
                            off_blk_amt = min(1, off_blk_amt)
                            off_damage *= (1 - off_blk_amt)
                            off_damage = int(off_damage * (1 - resist))
                            print("{} blocks {}'s attack and mitigates {} percent of the damage.".format(
                                defender.name, name, int(off_blk_amt * 100)))
                if int(off_damage) > 0:
                    if cover:
                        print("{} steps in front of the attack, taking the damage for {}.".format(
                            defender.familiar.name, defender.name))
                    else:
                        print("{} {} {} for {} damage.".format(name, off_typ, defender.name, off_damage))
                        defender.health -= off_damage
                else:
                    print("{} {} {} but deals no damage.".format(name, off_typ, defender.name))
        else:
            if 'Parry' in list(defender.spellbook['Skills'].keys()):  # TODO need to prevent infinite loop
                print("{} parries {}'s attack and counterattacks!".format(defender.name, name))
                _, _ = weapon_damage(defender, attacker)
            else:
                print("{} evades {}'s offhand attack.".format(defender.name, name))
        time.sleep(0.5)
    time.sleep(0.25)
    return hit, crit


def options(player, enemy, tile, action_list=None):
    """
    Controls the listed options during combat
    """
    print(tile.intro_text(player))
    if (player.cls == 'Inquisitor' or player.cls == 'Seeker' or 'Vision' in player.equipment['Pendant']().mod) and \
            'Chest' not in enemy.name and 'Door' not in enemy.name:
        print(enemy)
    print("Player: {} | Health: {}/{} | Mana: {}/{}".format(player.name, player.health, player.health_max,
                                                            player.mana, player.mana_max))
    print("Choose an action:")
    if action_list is not None:
        option_list = []
        for action in action_list:
            option_list.append(action.name)
        if 'Chest' not in enemy.name and 'Door' not in enemy.name and 'Boss' not in tile.intro_text(player):
            option_list.append(actions.Flee().name)
        action_input = storyline.get_response(option_list)
        return action_input


def player_turn(player, enemy, tile, available_actions, combat):
    valid_entry = False
    flee = False
    move = False
    action_input = options(player, enemy, tile, available_actions)
    try:
        action = available_actions[action_input]
    except IndexError:
        action = actions.Flee()
    if 'Move' in action.name:
        combat = False
        player.state = 'normal'
        valid_entry = True
        player.do_action(action, **action.kwargs)
        move = True
        return valid_entry, combat, move
    if action.name == 'Open':
        player.open_up(enemy)
        combat = False
        valid_entry = True
    if action.name == 'Attack':
        _, _ = weapon_damage(player, enemy)
        valid_entry = True
    if action.name == 'Item':
        valid_entry = player.use_item(enemy=enemy)
    if action.name == 'Flee':
        flee = character.Player.flee(player, enemy)
        valid_entry = True
    if action.name == 'Cast Spell':
        spell_list = []
        for entry in player.spellbook['Spells']:
            if player.spellbook['Spells'][entry]().cost <= player.mana:
                spell_list.append(str(entry) + '  ' + str(player.spellbook['Spells'][entry]().cost))
        spell_list.append('Go Back')
        spell_index = storyline.get_response(spell_list)
        if spell_list[spell_index] == 'Go Back':
            os.system('cls' if os.name == 'nt' else 'clear')
            return False, combat, move
        else:
            spell = player.spellbook['Spells'][spell_list[spell_index].split('  ')[0]]
            spell().cast(player, enemy)
            valid_entry = True
    if action.name == 'Use Skill':
        skill_list = []
        for entry in player.spellbook['Skills']:
            if player.spellbook['Skills'][entry]().cost <= player.mana:
                if player.spellbook['Skills'][entry]().passive:
                    continue
                elif player.spellbook['Skills'][entry]().name == 'Smoke Screen' and 'Boss' in \
                        tile.intro_text(player):
                    continue
                elif player.spellbook['Skills'][entry]().name == 'Lockpick' and \
                        enemy.name != 'Locked Chest':
                    continue
                elif player.spellbook['Skills'][entry]().name == 'Shield Slam' and \
                        player.equipment['OffHand']().subtyp != 'Shield':
                    continue
                elif enemy.name != 'Locked Chest':
                    skill_list.append(str(entry) + '  ' + str(player.spellbook['Skills'][entry]().cost))
                elif player.spellbook['Skills'][entry]().name == 'Lockpick' and enemy.name == 'Locked Chest':
                    skill_list.append(str(entry) + '  ' + str(player.spellbook['Skills'][entry]().cost))
        skill_list.append('Go Back')
        skill_index = storyline.get_response(skill_list)
        if skill_list[skill_index] == 'Go Back':
            os.system('cls' if os.name == 'nt' else 'clear')
            return False, combat, move
        else:
            valid = True
            skill = player.spellbook['Skills'][skill_list[skill_index].split('  ')[0]]
            if skill().name == 'Smoke Screen':
                player.mana -= skill().cost
                flee = player.flee(enemy, smoke=True)
            elif skill().name == 'Transform':
                skill().change(player)
                valid = False
            else:
                skill().use(player, enemy)
            valid_entry = valid
    if flee:
        """Moves the player randomly to an adjacent tile"""
        available_moves = tile.adjacent_moves()
        r = random.randint(0, len(available_moves) - 1)
        player.do_action(available_moves[r])
    return valid_entry, combat, move


def enemy_turn(player, enemy, combat):
    cover = False
    if not enemy.is_alive() and 'Chest' not in enemy.name:
        print("{} killed the {}.".format(player.name, enemy.name))
        if player.cls not in list(classes.classes_dict.keys()):
            transform(player, back=True)
        print("{} gained {} experience.".format(player.name, enemy.experience))
        player.loot(enemy)
        player.experience += enemy.experience
        while player.experience >= player.exp_to_gain:
            player.level_up()
        if player.cls == "Soulcatcher":
            absorb_essence(player, enemy)
        if player.cls in ['Warlock', 'Shadowcaster']:
            if player.familiar.typ == 'Jinkin' and player.familiar.pro_level == 3:
                if not random.randint(0, 9):
                    rand_item = items.random_item(player.location_z)
                    if not random.randint(0, 1):
                        print("{} finds {} but keeps it for themself.".format(
                            player.familiar.name, rand_item().name))
                    else:
                        player.modify_inventory(rand_item, 1)
                        print("{} finds {} and gives it to {}.".format(
                            player.familiar.name, rand_item().name, player.name))
        player.state = 'normal'
        return False
    elif player.state == 'normal' or 'Chest' in enemy.name or 'Door' in enemy.name:
        return False
    elif enemy.status_effects['Stun'][0] or enemy.status_effects['Sleep'][0]:
        combat = True
    else:
        if player.cls in ['Warlock', 'Shadowcaster']:
            if 'Cover' in list(player.familiar.spellbook['Skills'].keys()) and not random.randint(0, 3):
                cover = True
        enemy_spell_list = []
        enemy_skill_list = []
        for spell_name, spell in enemy.spellbook['Spells'].items():
            if enemy.spellbook['Spells'][spell_name]().cost <= enemy.mana:
                enemy_spell_list.append(spell)
        for spell_name, spell in enemy.spellbook['Skills'].items():
            if enemy.spellbook['Skills'][spell_name]().passive:
                continue
            elif enemy.spellbook['Skills'][spell_name]().cost <= enemy.mana:
                enemy_skill_list.append(spell)
        if len(enemy_spell_list) > 0 and len(enemy_skill_list) > 0:
            cast = random.randint(0, 2)
            if cast == 0:
                enemy_spell = enemy_spell_list[random.randint(0, len(enemy_spell_list) - 1)]
                enemy_spell().cast(enemy, player, cover=cover)
                try:
                    if enemy_spell().rank == 1:
                        if (player.cls == "Diviner" or player.cls == "Geomancer") and \
                                enemy_spell().name not in player.spellbook['Spells']:
                            player.spellbook['Spells'][enemy_spell().name] = enemy_spell
                            print(enemy_spell())
                            print("You have gained the ability to cast {}.".format(enemy_spell().name))
                    elif enemy_spell().rank == 2:
                        if player.cls == "Geomancer" and enemy_spell().name not in player.spellbook['Spells']:
                            player.spellbook['Spells'][enemy_spell().name] = enemy_spell
                            print(enemy_spell())
                            print("You have gained the ability to cast {}.".format(enemy_spell().name))
                except AttributeError:
                    pass
            elif cast == 1:
                enemy_skill = enemy_skill_list[random.randint(0, len(enemy_skill_list) - 1)]
                _ = enemy_skill().use(enemy, player, cover=cover)
            else:
                _, _ = weapon_damage(enemy, player, cover=cover)
        elif len(enemy_spell_list) > 0:
            cast = random.randint(0, 1)
            if cast:
                enemy_spell = enemy_spell_list[random.randint(0, len(enemy_spell_list) - 1)]
                enemy_spell().cast(enemy, player, cover=cover)
                try:
                    if enemy_spell().rank == 1:
                        if (player.cls == "Diviner" or player.cls == "Geomancer") and \
                                enemy_spell().name not in player.spellbook['Spells']:
                            player.spellbook['Spells'][enemy_spell().name] = enemy_spell
                            print(enemy_spell())
                            print("You have gained the ability to cast {}.".format(enemy_spell().name))
                    elif enemy_spell().rank == 2:
                        if player.cls == "Geomancer" and enemy_spell().name not in player.spellbook['Spells']:
                            player.spellbook['Spells'][enemy_spell().name] = enemy_spell
                            print(enemy_spell())
                            print("You have gained the ability to cast {}.".format(enemy_spell().name))
                except AttributeError:
                    pass
            else:
                _, _ = weapon_damage(enemy, player, cover=cover)
        elif len(enemy_skill_list) > 0:
            cast = random.randint(0, 1)
            if cast:
                enemy_skill = enemy_skill_list[random.randint(0, len(enemy_skill_list) - 1)]
                _ = enemy_skill().use(enemy, player, cover=cover)
            else:
                _, _ = weapon_damage(enemy, player, cover=cover)
        else:
            _, _ = weapon_damage(enemy, player, cover=cover)
        if enemy.health <= 0 and 'Chest' not in enemy.name:
            print("{} killed the {}.".format(player.name, enemy.name))
            if player.cls not in list(classes.classes_dict.keys()):
                transform(player, back=True)
            print("{} gained {} experience.".format(player.name, enemy.experience))
            player.loot(enemy)
            player.experience += enemy.experience
            while player.experience >= player.exp_to_gain:
                player.level_up()
            player.state = 'normal'
            return False
    if not player.is_alive():
        try:
            if 'Resurrection' in list(player.familiar.spellbook['Spells'].keys()) and random.randint(0, 1):
                spells.Resurrection().cast(player.familiar, target=player, fam=True)
        except AttributeError:
            pass
        if 'Resurrection' in list(player.spellbook['Spells'].keys()) and abs(player.health) <= player.mana:
            player.spellbook['Spells']['Resurrection']().cast(player, enemy)
        else:
            if player.cls not in list(classes.classes_dict.keys()):
                transform(player, back=True)
            print("{} was slain by the {}.".format(player.name, enemy.name))
            return False
    statuses(enemy)
    if not enemy.is_alive():
        print("{} killed the {}.".format(player.name, enemy.name))
        if player.cls not in list(classes.classes_dict.keys()):
            transform(player, back=True)
        print("{} gained {} experience.".format(player.name, enemy.experience))
        player.loot(enemy)
        player.experience += enemy.experience
        while player.experience >= player.exp_to_gain:
            player.level_up()
        if player.cls == "Soulcatcher":
            absorb_essence(player, enemy)
        if player.cls in ['Warlock', 'Shadowcaster']:
            if player.familiar.typ == 'Jinkin' and player.familiar.pro_level == 3:
                if not random.randint(0, 9):
                    rand_item = items.random_item(player.location_z)
                    if not random.randint(0, 1):
                        print("{} finds {} but keeps it for themself.".format(
                            player.familiar.name, rand_item().name))
                    else:
                        player.modify_inventory(rand_item, 1)
                        print("{} finds {} and gives it to {}.".format(
                            player.familiar.name, rand_item().name, player.name))
        player.state = 'normal'
        return False
    return combat


def battle(player, enemy, wmap):
    """
    Function that controls combat
    """
    tile = world.tile_exists(player.location_x, player.location_y, player.location_z)
    available_actions = tile.available_actions(player)
    combat = True
    move = False
    while player.is_alive() and enemy.is_alive():
        os.system('cls' if os.name == 'nt' else 'clear')
        tile.minimap(player, wmap)
        if player.status_effects['Stun'][0] or player.status_effects['Sleep'][0]:
            print("Player: {} | Health: {}/{} | Mana: {}/{}".format(player.name, player.health, player.health_max,
                                                                    player.mana, player.mana_max))
        else:
            while True:
                if player.cls in ['Warlock', 'Shadowcaster']:
                    if 'Lockpick' in list(player.familiar.spellbook['Skills'].keys()) and \
                            enemy.name == 'Locked Chest':
                        player.familiar.spellbook['Skills']['Lockpick']().use(player, target=enemy, fam=True)
                        combat = False
                        break
                valid_entry, combat, move = player_turn(player, enemy, tile, available_actions, combat)
                if valid_entry:
                    break
                else:
                    tile.minimap(player, wmap)
                if player.cls not in list(classes.classes_dict.keys()):
                    available_actions = tile.available_actions(player)
        if move:
            break
        time.sleep(0.5)

        # Familiar's turn
        if combat:
            if player.cls in ['Warlock', 'Shadowcaster'] and enemy.is_alive():
                familiar(player, enemy)

        if not player.is_alive():
            if 'Resurrection' in list(player.spellbook['Spells'].keys()) and abs(player.health) <= player.mana:
                player.spellbook['Spells']['Resurrection']().cast(player, enemy)
            else:
                if player.cls not in list(classes.classes_dict.keys()):
                    transform(player, back=True)
                print("{} was slain by the {}.".format(player.name, enemy.name))
            combat = False

        # Enemies turn
        if combat:
            combat = enemy_turn(player, enemy, combat)
        if not combat:
            break
        statuses(player)
        input("Press enter to continue")

    player.state = 'normal'

    player.status_effects['Stun'][0] = False
    player.status_effects['Doom'][0] = False
    player.status_effects['Blind'][0] = False
    player.status_effects['Disarm'][0] = False
    player.status_effects['Sleep'][0] = False
    player.status_effects['Reflect'][0] = False
    player.status_effects['Poison'][0] = False
    player.status_effects['DOT'][0] = False
    player.status_effects['Bleed'][0] = False
    player.status_effects['Regen'][0] = False
    player.status_effects['Attack'][0] = False
    player.status_effects['Defense'][0] = False
    player.status_effects['Magic'][0] = False
    player.status_effects['Magic Def'][0] = False
